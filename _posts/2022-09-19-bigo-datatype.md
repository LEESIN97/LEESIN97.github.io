---
layout: single
title:  "빅오와 파이썬의 자료형"
excerpt: "박상길, 『파이썬알고리즘인터뷰』, 책만(2020), p99-136."

categories: Python
tag: [Python, datatype, algorithm]

toc: true
toc_sticky: true

author_profile: true
sidebar: true

search: true
 
date: 2022-09-19
last_modified_at: 2022-09-19
---

<br/><br/>

# big-O (빅오)

<br/>

<br/>

## big-O (빅오)

빅오란 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법.

빅오로 시간 복잡도를 표현할 때는 최고차항만을 표기하며, 계수는 무시한다.

ex) $4n^2 + 3n + 4$ 는 $O(n^2)$ 으로 시간복잡도를 나타낸다.



* $O(1)$ : 입력값이 아무리 커도 실행시간이 일정하다.

  

* $O(logn)$ : 실행 시간은 입력값에 영향을 받는다. 하지만 웬만한 $n$의 크기에 대해서도 매우 견고하다.

  

* $O(n)$ : 입력값 만큼 실행 시간이 영향을 받는다. 선형 시간 알고리즘이라고도 한다. 

  

* $O(nlogn)$ : 대부분의 효율 좋은 정렬 알고리즘이 이에 해당. 

  

* $O(n^2)$ : 버블정렬과 같은 비효율적인 정렬 알고리즘이 해당.

  

* $O(2^n)$ : 재귀로 계산하는 알고리즘이 이에 해당.

  

* $O(n!)$ : 가장 느린 알고리즘. 입력값이 조금만 커져도 다항 시간 내에 계산이 힘들다.

  

빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰이는데, 시간과 공간이 트레이드오프 관계이다.

<br/><br/>

## 상한과 최악

빅오 표기법은 '적당히 정확하게' 표현하는 방법일 뿐, 최악의 경우/ 평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이다. 

책의 빅오의 관련한 이부분에 대해서는 내가 이해한 바를 적어보도록 하겠다.

어떠한 알고리즘에 따라 결과값이 도출 되는데에 입력값이 최악의 경우가 있을 수도 있고 평균적인 경우가 있을 수도 있고 최선의 경우가 있을 수도 있다.

입력값에 따라 빅오 표기법에서의 $O(f(n))$ 에서 $f(n)$이 무엇을 따르는지가 달라질 수가 있는데, $f(n)$을 나타낼 때 n이 무한히 클 때의 영향을 가장 많이 받는 항을 나타낸다. 



즉, 가장 늦게 실행될 때(상한) 을 $f(n)$으로 나타내게 된다.  위에서 예를 들었던 $4n^2 + 3n + 4$ 는 $O(n^2)$ 으로 시간복잡도를 나타낸다. 가 이에 해당한다.

<br/><br/>

## 분할 상환 분석

최악의 경우가 어쩌다 한번 일어나는 경우인데 이때의 시간복잡도를 계산하는 것은 비관적이고 정확하지도 않다고 보는 견해이다.

예를들어 '동적배열' 에서는 더블링이 어쩌다 한번 일어나 시간복잡도가 그 경우에 $O(n)$ 이다. 

이 때 최악의 경우, 더블링이 일어나는 경우를 여러 번에 걸쳐 골고루 나눠 주어 시간복잡도를 계산하여 시간 복잡도를 O(1)로 나타낸다. 

<br/><br/>

## 병렬화

일부 알고리즘은 병렬화로 속도를 높일 수 있다. GPU 가 병렬 연산을 위한 대표적인 장치인데, 이는 CPU에 비해 각각의 코어의 속도가 매우 느리지만 코어가 수천개로 구성되어 있어 CPU보다 더 많은 연산을 동시에 할 수 있다.

딥러닝 알고리즘을 비롯해 병렬화 가능한지의 여부는 알고리즘의 우수성을 평가하는 중요한 척도이다.

<br/><br/>

# 자료형



<br/><br/>

## 숫자

* 정수형 : 파이썬의 버전 3부터는 int 단일형으로, int는 임의 정밀도를 지원한다. 

* 불리안 : bool은 내부적으로 int의 서브 클래스다. 

임의 정밀도로 지원한다는 것은 숫자를 배열로 간주한다는 것이다.

계산 속도가 저하가 되지만, 매우 단순한 구조이고 오버플로를 고민할 필요가 없어진다.

<br/><br/>

## 매핑

키와 자료형으로 구성된 복합 자료형, 파이썬에서는 유일한 매핑 자료형인 딕셔너리가 있다.

```python
a = {'a': 'A'}
```



<br/><br/>

## 집합

중복된 값을 갖지 않는 자료형이다. 

```python
a = set()
```

다음과 같은 형태로 선언한다.



집합은 딕셔너리와 같이 동일하게 중괄호를 사용하므로 유의해야 한다.

set은 입력 순서가 유지되지 않으며, 중복될 경우 하나의 값만 유지한다.

<br/><br/>

## 시퀀스

- Immutable : str, tuple, bytes 가 이에 해당한다.

  ```python
  a = 'abc'
  a = 'def'
  ```

  위와 같은 경우에는 변수 a는 'abc'를 참조했다 'def'를 참조한 것뿐이지 변경된 것이 아니다.

  

- Mutable : list

  <br/><br/>

## 파이썬의 자료형 특징

파이썬은 편리한 기능 제공에 우선순위를 두었다.

속도가 느리고, 많은 메모리를 차지하더라도 다양한 기능을 제공하는 객체에 관심을 둔다.



<br/><br/>

## 객체

* 불변 객체 : list, set, dict 제외한 자료형

  * 변수를 할당하는 작업은 객체에 대해 참조를 한다는 의미이다.

  * 상수처럼 read-only 용도로 사용하거나 무엇보다 값이 변하지 않는 것들은 dict의 키나 set의 값으로 사용할 수 있다.

* 가변객체 : list, set, dict

참고) is는 id() 값을 비교하는 함수이다. None은 null이므로 값을 비교할 수 없으므로 ==로 비교가 불가능하다.

<br/><br/>

## 리스트

동적배열로 구성이 되어있다. 

```python
a = list() # 리스트는 다음과 같이 선언한다.
a = [] # 간단하게 선언
a = [1, 2, 3]
a.append(4) # 요소추가 숫자 외에도 다양한 자료형을 단일 리스트에 관리가 가능하다.
a.insert(3, 5) # 특정 위치의 인덱스를 지정해 요소를 추가한다.
a[3] # 특정 index의 값을 꺼내올 수 있다.
a[1:3] # slicing을 통해 여러 index의 값을 가져올 수 있다. 마지막 index는 포함하지 않는다.
a[:3] # 시작인덱스를 생략 시작 index는 0부터 시작
a[4:] # 마지막까지 slicing
a[1:4:2] # 다음과 같이 홀수 번째의 index만 slicing을 할 수 있다.
```

리스트를 del 키워드를 사용하거나, remove()함수를 사용하거나 pop()함수를 사용해 제거할 수 있다.

이때 pop()은 삭제를 하는 동시에 반환을 하게 된다.

<br/>

###  리스트의 특징

리스트는 객체에 대한 포인터 목록을 관리하는 형태로 구현되어 있다. 

그러므로 정수, 문자, 불리언 등 제각기 다양한 타입을 동시에 단일 리스트에서 관리하는게 가능하다.

<br/><br/>

## 딕셔너리

키/값 구조로 이뤄진 딕셔너리이다. 3.7+에서는 순서가 유지된다. (3.6+ 에서는 collections.OrderedDict()를 통해 ) 내부적으로는 Hash Table로 구현되어 있다.

해시할 수만 있다면 불변 객체를 모두 키로 사용한다.

입력과 조회 모두 $O(1)$에 가능하며, 최악의 경우  $O(n)$이 될 수도 있지만 분할 상환 분석에 의해 $O(1)$이 된다.

딕셔너리는 대부분의 연산이 $O(1)$에 처리 가능하다.

```python
a = dict() 
a = {} # 간단하게 선언
a = {'key' : 'value1'} # 초기값 지정해 선언
a['key2'] = 'value2' # 나중에 별도로 선언
a['key1'] # key를 통해 값을 조회할 수 있다.
for k, v in a.items(): # 키와 값을 각각 꺼내올 수 있다.
    print(k, v)
del a['key1'] # del 키워드를 통해 요소를 삭제할 수도 있다. try나 조건문을 통해 예외처리할 수 있다.

```

<br/>

### 딕셔너리 모듈

* defaultdict 객체

  ```python
  a = collections.defaultdict(int) #존재하지 않는 키에 default값이 존재한다. 여기서는 0
  a = ['C'] += 1 # KEY는 C이고 VALUE는 1을 가지게 된다.
  ```

* Counter 객체

  아이템에 대한 개수를 계산해 딕셔너리로 반환한다.

  ```python
  a = [1, 2, 3, 4, 5, 5, 6, 6]
  b = collections.Counter(a) # 딕셔너리를 한번더 Wrapping한 collections.Counter 클래스를 갖는다.
  b.most_common(2) # 가장 빈도수가 높은 요소 2개를 추출한다.
  ```

* OrderedDict 객체

​	입력순서가 유지된다. 

```python
collections.OrderedDict({'banana' : 3, 'apple' : 4})
```

​	파이썬 버전 3.7부터는 내부적으로 입력 순서가 유지된다.

